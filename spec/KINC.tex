\documentclass[10pt]{article}
\usepackage[T1]{fontenc}
\usepackage{tabularx}
\usepackage{parskip}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{soul}
\usepackage{mdframed}
\usepackage{listings}
\usepackage[margin=1in]{geometry}

\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\definecolor{btablecol}{rgb}{.9,.9,.9}
\mdfdefinestyle{btable}{
hidealllines=true,
backgroundcolor=btablecol,
innertopmargin=3mm,
innerbottommargin=3mm}

\definecolor{funclistbcol}{rgb}{.9,.9,1}
\definecolor{funclistlcol}{rgb}{.6,.6,1}
\mdfdefinestyle{functions}{
backgroundcolor=funclistbcol,
topline=false,
bottomline=false,
linecolor=funclistlcol,
linewidth=2mm}

\definecolor{lyellow}{rgb}{1,1,0.2}
\definecolor{lblue}{rgb}{0.8,0.8,1}
\providecommand{\stephen}[1]{\sethlcolor{lyellow}\hl{#1}}
\providecommand{\josh}[1]{\sethlcolor{lblue}\hl{#1}}

\definecolor{darkblue}{rgb}{0,0,0.6}
\providecommand{\h}[1]{\textcolor{darkblue}{#1}}

\setlength{\parindent}{0cm}

\begin{document}

\title{\textbf{KINC v0.1 Specification}\\
\vspace{1mm}
\includegraphics[width=8cm,height=4cm]{KINClogo.png}
\\Knowledge Independent Network Construction}
\author{Joshua Burns\thanks{Dept. of Horticulture, Washington State 
University}, Stephen Ficklin\footnotemark[1]}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Introduction}

KINC is designed for use in construction of biological networks, specifically, 
gene co-expression networks.

KINC performs three major steps:

\begin{list}{}{}
\item[1)] Construction of a similarity matrix of pair-wise expression 
correlations.
\item[2)] Thresholding of the similarity matrix to form an adjaceny matrix.
\item[3)] Export of the adjaceny matrix to form a tab-delimited network file.
\end{list}

This document provides an overview for the data structures and file formats 
used 
by KINC. 

\newpage
\section{Console}

The \h{Console} class has a single instance within the main program and is 
designed to be given control through its \h{run()} 
function. This class creates a terminal console for the user, creates and 
manages all \h{Data} objects, and handles all \h{Analytic} execution.

This class also interfaces with the plugin object factory functions that 
generate new data or analytic interface object based off their unique names. 
These functions are implemented in a common source file which requires editing 
whenever a new plugin is added to the program.

\autoref{fig:console:func} shows the functions this class implements.

The constructor takes any command line arguments.

\begin{figure}[H]
\begin{mdframed}[style=functions]
\begin{lstlisting}[language=C++]
Console(int,char*[]);
void run();
bool __register(Data*,std::string&);
bool unregister(std::string&);
Data* find(std::string&);
Data* new_data(std::string&);
Analytic* new_analytic(std::string&);
\end{lstlisting}
\end{mdframed}
\caption{Functions for Console Class}
\label{fig:console:func}
\end{figure}

The \h{run(...)} function takes control of the process and runs a console for 
the user or executes a script, depending on the command line arguments 
supplied. Once the user exits the console or the script has finished executing 
this function returns control to the caller.

The \h{\_\_register(...)} function adds a new \h{Data} object to the list of 
available \h{Data} objects within the console with the name string supplied. 
The name must be unique from all other loaded \h{Data} objects.

The \h{unregister(...)} function removes the \h{Data} object with the name 
string specified if it exists. If it exists and it was removed it returns 
\h{TRUE} else it returns \h{FALSE}.

The \h{find(...)} function finds a loaded \h{Data} object with the given name. 
If no object is found with that name then \h{NULL} is returned, else a 
pointer to the found object is returned.

The \h{new\_data(...)} function creates a new data object of the type 
specified in the supplied string. If the string is not a valid data type then 
\h{NULL} is returned, else a pointer to the new data object is returned.

The \h{new\_analytic(...)} creates a new analytic object of the type specified 
in the supplied string. If the string is not a valid data type then \h{NULL} is 
returned, else a pointer to the new analytic object is returned.

The \h{new\_data(...)} and \h{new\_analytic(...)} functions are designed to be 
plugin object factories which return data and analytic objects with the type 
given to them as a string. These two functions along with the list of all 
available plugins containing their unique string names and unique number 
identifiers are all contained in the same source and header file. These two 
files will represent where new static plugins that implement either a data or 
analytic interface can be added.

\newpage
\section{Data}

The abstract \h{Data} class creates a common data object interface to the 
console program and provides file input/output for any data class implementing 
it. This class is responsible for implementing the basic file input and output 
operations along with specifying a common interface with the console program.

Additional functions can and should be added to any implementation of this 
interface class that deals with manipulating the specific type of data that is 
being implemented.

\autoref{fig:data:func} shows the public functions this class defines. 
Exluding the constructor, all of these functions are pure virtual functions 
that any class inheriting this class are required to implement. The constructor 
takes a single argument which is the binary file location where the data for an 
object is stored.

\begin{figure}[H]
\begin{mdframed}[style=functions]
\begin{lstlisting}[language=C++]
Data(const std::string&);
void __history();
virtual uint32_t type() = 0;
virtual bool __load(std::vector<std::string>&) = 0;
virtual bool __export(std::vector<std::string>&) = 0;
virtual bool __query(std::vector<std::string>&) = 0;
virtual bool __merge(std::vector<std::string>&) = 0;
virtual bool flush() = 0;
\end{lstlisting}
\end{mdframed}
\caption{Functions for Data Class}
\label{fig:data:func}
\end{figure}

The \h{history()} function prints the entire history of its object to standard 
output.

The virtual \h{type()} function must return the unique identier of the type of 
data this object represents. The list of unique identifiers are stored in a 
common header file.

The \h{load(...)}, \h{\_\_export(...)}, \h{query(...)}, and \h{merge(...)} 
functions are all supplied with the same argument. This argument is a list of 
additional arguments given to the specific command issued by the user on the 
console.

The virtual \h{load(...)} function is called when a load console command 
is issued on a new data object. The data object instance can assume that it is 
empty and was just created by the console. This function is responsible for 
loading data from a human readable ASCII file and encoding it into its binary 
format in a new file of the same name.

The virtual \h{\_\_export(...)} function is called when a export console command 
is issued on a given data object. This function is responsible for exporting 
its internal data stored in binary format and decoding it into a human readable 
ASCII file.

The virtual \h{query(...)} function is called when a query console command is 
issued on a given data object. This function is responsible for giving 
information about the data this object holds to the user based off arguments 
given.

The virtual \h{merge(...)} function is called when a merge console command is 
issued on a given data object. This function is responsible for merging two or 
more seperate data objects of the same type into a new single data object. The 
data object this command is called on is the first data object in the list of 
objects that will be merged. The rest of the objects are supplied as additional 
arguments. This function does not have to merge the given data objects if the 
data is of a type that cannot be merged without calling an analytic object.

The \h{load(...)}, \h{\_\_export(...)}, \h{merge(...)}, and \h{flush()} 
functions will not return control to the caller of the function until all write 
operations to the binary file the data object represents have completed.

\autoref{fig:data:func:prot} shows the protected functions this class 
implements that a class inheriting this abstract class can use for file input 
and output of its binary data.

\begin{figure}[H]
\begin{mdframed}[style=functions]
\begin{lstlisting}[language=C++]
uint64_t fsize();
void fseek(uint64_t);
template<class T> bool fread(T*,uint64_t);
template<class T> bool fwrite(T*,uint64_t);
\end{lstlisting}
\end{mdframed}
\caption{Protected Functions for Data Class}
\label{fig:data:func:prot}
\end{figure}

Add descriptions of file input/output functions here.

This abstract class is responsible for reading in the header information of any 
data file since it is generic to any specific data type. 
\autoref{fig:kincdata:header} shows the binary format for the beginning of any 
KINC data file. \h{headerTag} represents the specific data type this file 
represents. The rest of the header information is the history information for 
this data, starting with how this specific data was created.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|l|X|l|}
\hline
\textbf{Name} & \textbf{Value} & \textbf{Description} & \textbf{Type} \\
\hline
header & KINC & Special header tag specifying this is a KINC binary data file. 
& char[4] \\
\hline
type & & Number that defines Data type for a file. & uint32\_t \\
\hline
historySize & & Total size of all history items in bytes. & uint32\_t \\
\hline
history & & Array of history items. & byte[historySize] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Header}
\label{fig:kincdata:header}
\end{figure}

\autoref{fig:kincdata:history} shows the format for a single history item. The 
history item structure is a nested structure with subhistories of all input 
files used to create the current history item. This nesting continues until you 
reach the origional files that were created through importation of data outside 
of KINC. The first history item in any file is a reference of itself, therefore 
any data file has at least one history item which describes itself. Any sub 
history items after that describe any input files that helped create this file.

\h{file} is the filename of the input file or an empty string if this is the 
first history item referencing itself. \h{name} is the user defined name of the 
file and its data. \h{object} is teh name of the KINC Analytic or Data class 
which created this file. \h{description} is a detailed description about the 
creation of the data. Lastly, \h{date} is a linux timestamp of the time this 
file was created or last modified.

The \h{subHistory} items represent a list of further history items that 
describe all input files used in the creation of this current history item.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Type} \\
\hline
elemSize & The total size of this history item and all subhistory items it 
bytes. & uint64\_t \\
\hline
fileLen & Length of file name string in bytes. & uint16\_t \\
\hline
nameLen & Length of user defined name string in bytes. & uint16\_t \\
\hline
objectLen & Length of object name string in bytes. & uint16\_t \\
\hline
descriptionLen & Length of description string in bytes. & uint16\_t \\
\hline
commandLen & Length of command string in bytes. & uint16\_t \\
\hline
date & Linux time-stamp of when file was last modified. & uint64\_t \\
\hline
subHistoryAmt & Number of input history items. & uint16\_t \\
\hline
subHistorySize & Size of input history data in bytes. & uint32\_t \\
\hline
file & File name string. & char[fileLen] \\
\hline
name & User defined name string. & char[nameLen] \\
\hline
object & Name of object that built file in bytes. & char[objectLen] \\
\hline
description & Detailed description of how file was built. & 
char[descriptionLen] \\
\hline
command & Command line used in console to construct data file. & 
command[commandLen] \\
\hline
subHistory & Array of input history items. & byte[subHistorySize] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Individual History Item}
\label{fig:kincdata:history}
\end{figure}

\newpage
\section{Analytic}

The Analytic class is responsible for taking in one or more Data objects
and employ an algorithm such as a statistical test to produce one or more 
new Data objects.   A Analytic 

\begin{figure}[H]
\begin{mdframed}[style=functions]
\begin{lstlisting}[language=C++]
Analytic(cl::Context*);
virtual uint32_t type() = 0;
virtual bool execute(std::vector<std::string>&) = 0;
\end{lstlisting}
\end{mdframed}
\caption{Functions for Analytic Class}
\label{fig:kincanalytic}
\end{figure}

\newpage
\section{Data Classes}

\subsection{Expression}

The Expression class is responsible for manging gene expression-level data.  

\subsubsection{Properties}

\stephen{Do we need any properties?}

\josh{I don't think we need properties. I am also unsure how to implement them 
in C++. My thought is all interactions between the classes will be defined in 
the Abstract Classes section using virtual functions?}

\subsubsection{Constructor}

{\bfseries Data(int argc, char *argv[])}

\stephen{We need to design how the functions of the class will receive 
arguments.  will we have a constructor that receives, parses and responds to 
errors for all functions?  Or should each function be responsible for checking 
it's own arguments. I know we can't do that in the abstract class, but 
we need to accomdate the behavior we settle on in our design so plugins
are consistent.}

\josh{I almost completely agree. These functions and interactions will all be 
defined in the abstract classes section if that is OK? It is standard C++ to 
define everything you are talking about in the abstract interface class with 
virtual functions. It is usually a good idea to have a default constructor only 
for implemenation classes, and have any additional configuation added into 
additional virtual functions that any implementation must handle.}

\subsubsection{Virtual Functions}

The following functions should be implemented by any plugin that creates
classes that inherits the Data class.

{\bfseries virtual void import() = 0}

This function reads a tab-delimited file.  Each line of this file
represents the gene expression levels of a single gene, transcript or probeset.
Each tab-separated value in a single line indicates the gene expression level 
for each sample. The expression level of a samples must be in the same 
order for every line.  The first line of the file may contain a tab-delimited
list of sample names, and a file may contain as many samples and genes as
desired.

\subsubsection{File Structure}

\autoref{fig:expression} shows the binary format of expression data and how it 
is stored on file. \h{geneAmt} and \h{sampleAmt} give the total number of genes 
and samples in the data, respectively. \h{geneNames} is the list of all gene 
names as a string who's length and partitioning is defined by \h{geneNameLen} 
and \h{geneNameSize}. \h{sampleNames} is the list of all sample names as a 
string who's length and partitioning is defined by \h{sampleNameLen} and 
\h{sampleNameSize}. Lastly, \h{samples} is 2 dimensional matrix of all samples 
for each gene, where the matrix is sorted by gene major order.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Type} \\
\hline
geneAmt & Total number of genes. & uint32\_t \\
\hline
sampleAmt & Number of samples per gene. & uint32\_t \\
\hline
geneNameLen & Length of each string identifying genes. & uint16\_t \\
\hline
geneNameSize & Total size of gene name list in bytes. & uint64\_t \\
\hline
sampleNameLen & Length of each string identifying samples. & uint16\_t \\
\hline
sampleNameSize & Total size of sample name list in bytes. & uint64\_t \\
\hline
geneNames & List of gene string identifiers. & char[geneNameSize] \\
\hline
sampleNames & List of sample string identifiers. & char[sampleNameSize] \\
\hline
sampleTotal & Total number of samples for all genes. & uint64\_t \\
\hline
samples & List of all samples per gene. & float[sampleTotal] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Expression Data}
\label{fig:expression}
\end{figure}

\subsection{Correlation}

This is responsible for storing correlation data between genes.

The following describes the format of the KINC correlation file. All 
multi-byte numbers are little-endian, regardless of the machine endianness.

\stephen{I like this type of table for describing the file format. I borrowed 
it from the BAM file specification}

\josh{So do I! I was actually going to convert these defintions to a tabular 
format after your first review. :)}

\autoref{fig:correlation} shows the binary format of correlation data and how 
it is stored on file. \h{geneAmt}, \h{sampleAmt}, and \h{corrAmt} give the 
number of genes, number of samples per gene, and number of correlations per 
gene, respectively. \h{geneNames} is the list of all gene names that are 
correlated who's length and partitioning is defined by \h{geneNameLen} and 
\h{geneNameSize}. \h{sampleNames} is the list of all sample names used for 
correlation between genes who's length and partitioning is defiend by 
\h{sampleNameLen} and \h{sampleNameSize}. \h{corrTypes} is the list of all 
correlation types listed for all gene pairs who's length and partitioning is 
defined by \h{corrTypeLen} and \h{corrTypeSize}. Lastly, \h{correlations} is a 
special diagonal matrix where all correlations for gene pairs are stored using 
gene major order.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Type} \\
\hline
geneAmt & Total number of genes. & uint32\_t \\
\hline
sampleAmt & Number of samples per gene. & uint32\_t \\
\hline
corrAmt & Number of correlations per gene relationship. & uint8\_t \\
\hline
geneNameLen & Length of each string identifying genes. & uint16\_t \\
\hline
geneNameSize & Total size of gene name list in bytes. & uint64\_t \\
\hline
sampleNameLen & Length of each string identifying samples. & uint16\_t \\
\hline
sampleNameSize & Total size of sample name list in bytes. & uint64\_t \\
\hline
corrTypeLen & Length of each string identifying correlation type. & uint16\_t \\
\hline
corrTypeSize & Total size of correlation type list in bytes. & uint16\_t \\
\hline
geneNames & List of gene string identifiers. & char[geneNameSize] \\
\hline
sampleNames & List of sample string identifiers. & char[sampleNameSize] \\
\hline
corrTypes & List of correlation type strings. & char[corrTypeSize] \\
\hline
corrTotal & Total number of correlations for all gene relationships. & 
uint64\_t \\
\hline
correlations & Diagonal matrix list of all gene correlations for all 
relationships. & float[corrTotal] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Correlation Data}
\label{fig:correlation}
\end{figure}

\subsection{Network}

This is responsible for storing network data between genes.

\autoref{fig:network} shows the binary format of network data and how it is 
stored on file. \h{geneAmt} give the number of genes in the network. 
\h{geneNames} is the list of all gene names that are correlated who's length 
and 
partitioning is defined by \h{geneNameLen} and \h{geneNameSize}. Lastly, 
\h{network} is a special diagonal matrix where all network edges for gene pairs 
are stored using gene major order.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Type} \\
\hline
geneAmt & Total number of genes. & uint32\_t \\
\hline
geneNameLen & Length of each string identifying genes. & uint16\_t \\
\hline
geneNameSize & Total size of gene name list in bytes. & uint64\_t \\
\hline
geneNames & List of gene string identifiers. & char[geneNameSize] \\
\hline
netTotal & Total number of edges, true or false, in network data. & uint64\_t \\
\hline
network & Diagonal matrix list of all possible edges in gene network. & 
bool[netTotal] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Network Data}
\label{fig:network}
\end{figure}

\subsection{Annotation}

This is responsible for storing additional information for genes.

\autoref{fig:annotation} shows the binary format of annotation data and how it 
is stored on file. \h{geneAmt} and \h{annotAmt} give the number of genes and 
the number of annotations, respectively. \h{geneNames} is the list of all gene 
names who's length and partitioning is defined by \h{geneNameLen} and 
\h{geneNameSize}.\h{annotNames} is the list of all annotation names who's 
length and partitioning is defined by \h{annotNameLen} and \h{annotNameSize}.
\h{annotValSize} is a list of all string lengths for each annotation value per 
each gene. Lastly, \h{annotations} is a 2 dimensional matrix that lists all 
annotations for all genes using gene major order.

\begin{figure}[H]
\begin{mdframed}[style=btable]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Type} \\
\hline
geneAmt & Total number of genes. & uint32\_t \\
\hline
annotAmt & Total number of annotations per gene. & uint32\_t \\
\hline
geneNameLen & Length of each string identifying genes. & uint16\_t \\
\hline
geneNameSize & Total size of gene name list in bytes. & uint64\_t \\
\hline
annotNameLen & Length of each string identifying the name of a annotation. & 
uint16\_t \\
\hline
annotNameSize & Total size of annotation name list in bytes. & uint64\_t \\
\hline
annotNames & List of annotation string identifiers. & char[annotNameSize] \\
\hline
geneNames & List of gene string identifiers. & char[geneNameSize] \\
\hline
annotValLens & List of numbers that identify the length of each value string 
for each annotation. & uint16\_t[annotAmt] \\
\hline
annotValSize & Total size of all annotation values. & uint64\_t \\
\hline
annotations & List of all annotations per gene. & char[annotValSize] \\
\hline
\end{tabularx}
\end{mdframed}
\caption{Binary File Format of Annotation Data}
\label{fig:annotation}
\end{figure}

\newpage
\section{Analytic Classes}

\subsection{Pearson}

This takes an Expression BioData object and produces a Correlation BioData 
object. It uses the Pearson correlation statistical method for giving 
correlation values.

\subsection{Spearman}

This takes an Expression BioData object and produces a Correlation BioData 
object. It uses the Spearman correlation statistical method for giving 
correlation values.

\end{document}
