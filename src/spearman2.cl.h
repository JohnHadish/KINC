const char* spearman2_cl = 
"/* BASIC PLAN FOR NEW SPEARMAN KERNEL..\n"
"\n"
"Prune lists... ignoring infinities\n"
"IF pruned list is big enough... (else just make result NaN)\n"
"use bitonic sort with for loop to do 2 required sorts for spearman\n"
"make summation of rank differences\n"
"compute the spearman coefficient\n"
"\n"
"\n"
"MEMORY REQUIREMENTS...\n"
"will need TWO float arrays of size n\n"
"one int array of size n\n"
"where n is the number of samples per gene\n"
"in turn, this will be multilpied by the total number of threads\n"
"so size = ( 2*sizeof(float) + sizeof(int) )*thread_size\n"
"\n"
"*/\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Fetch and build array of expressions for both genes, skipping any expressions that are missing\n"
"// for either gene. Also builds ordered rank list used for spearman algorithm.\n"
"//\n"
"// @param indexA Index into expression list for gene A.\n"
"// @param indexB Index into expression list for gene B.\n"
"// @param size Size of lists for both genes.\n"
"// @param workSize Size of new work arrays for genes and rank list.\n"
"// @param listA New array of expressions for gene A that this function builds.\n"
"// @param listB New array of expressions for gene B that this function builds.\n"
"// @param rankList New array that is initialized to start at 1 and increment by one for each\n"
"// successive element.\n"
"// @param expressions Array of all expressions for all genes to generate gene lists from.\n"
"// @return Returns size of newly generated arrays which excludes any missing expression values.\n"
"int fetchLists(int indexA, int indexB, int size, int workSize, __global float* listA\n"
"               , __global float* listB, __global int* rankList, __global float* expressions)\n"
"{\n"
"   // initialize counters\n"
"   int i;\n"
"   int j = 0;\n"
"   int newSize = 2;\n"
"\n"
"   // go through expression list with given indexes, generating new lists from it\n"
"   for (i = 0; i < size ;++i)\n"
"   {\n"
"      if ( !isnan(expressions[indexA+i]) && !isnan(expressions[indexB+i]) )\n"
"      {\n"
"         // if both expressions exist add expressions to new lists, next rank, and increment\n"
"         listA[j] = expressions[indexA+i];\n"
"         listB[j] = expressions[indexB+i];\n"
"         rankList[j] = j+1;\n"
"         j++;\n"
"      }\n"
"   }\n"
"\n"
"   // set new size of generated lists and set unused end of lists to infinity or zero\n"
"   newSize = j;\n"
"   for (i = j; i < size;++i)\n"
"   {\n"
"      listA[i] = INFINITY;\n"
"      listB[i] = INFINITY;\n"
"      rankList[i] = 0;\n"
"   }\n"
"\n"
"   // set any remaining values in work arrays to infinity or zero\n"
"   for ( i = size; i < workSize ;++i)\n"
"   {\n"
"      listA[i] = INFINITY;\n"
"      listB[i] = INFINITY;\n"
"      rankList[i] = 0;\n"
"   }\n"
"\n"
"   // return new size for generated lists\n"
"   return newSize;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Swap two floating point values.\n"
"//\n"
"// @param a First floating point value.\n"
"// @param b Second floating point value.\n"
"void swapF(__global float* a, __global float* b)\n"
"{\n"
"   float c = *a;\n"
"   *a = *b;\n"
"   *b = c;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Sort a given list using the bitonic algorithm along with rearranging a second list with the same\n"
"// operations that are done to sort the sorted list.\n"
"//\n"
"// @param size Size of lists. It MUST be a power of 2.\n"
"// @param sortList The list to be sorted.\n"
"// @param extraList The extra list that will be rearranged identical to the sorted list.\n"
"void bitonicSortFF(int size, __global float* sortList, __global float* extraList)\n"
"{\n"
"   // initialize all variables\n"
"   int bsize = size/2;\n"
"   int ob,ib,i,dir,a,b,t;\n"
"\n"
"   // bitonic algorithm, starting with an outer block of 2 and working up to total size of list\n"
"   for (ob = 2; ob <= size ;ob *= 2)\n"
"   {\n"
"      for (ib = ob; ib >= 2 ;ib /= 2)\n"
"      {\n"
"         t = ib/2;\n"
"         for (i = 0; i < bsize ;++i)\n"
"         {\n"
"            dir = -((i/(ob/2))&0x1);\n"
"            a = (i/t)*ib+(i%t);\n"
"            b = a+t;\n"
"            if ( ( ( sortList[a] > sortList[b] ) && !dir )\n"
"                 || ( ( sortList[a] < sortList[b] ) && dir ) )\n"
"            {\n"
"               swapF(&sortList[a],&sortList[b]);\n"
"               swapF(&extraList[a],&extraList[b]);\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Swap two integer values.\n"
"//\n"
"// @param a First integer value.\n"
"// @param b Second integer value.\n"
"void swapI(__global int* a, __global int* b)\n"
"{\n"
"   int c = *a;\n"
"   *a = *b;\n"
"   *b = c;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Sort a given list using the bitonic algorithm along with rearranging a second list with the same\n"
"// operations that are done to sort the sorted list.\n"
"//\n"
"// @param size Size of lists. It MUST be a power of 2.\n"
"// @param sortList The list to be sorted.\n"
"// @param extraList The extra list that will be rearranged identical to the sorted list.\n"
"void bitonicSortFI(int size, __global float* sortList, __global int* extraList)\n"
"{\n"
"   // initialize all variables\n"
"   int bsize = size/2;\n"
"   int ob,ib,i,dir,a,b,t;\n"
"\n"
"   // bitonic algorithm, starting with an outer block of 2 and working up to total size of list\n"
"   for (ob = 2; ob <= size ;ob *= 2)\n"
"   {\n"
"      for (ib = ob; ib >= 2 ;ib /= 2)\n"
"      {\n"
"         for (i = 0; i < bsize ;++i)\n"
"         {\n"
"            dir = -((i/(ob/2))&0x1);\n"
"            t = ib/2;\n"
"            a = (i/t)*ib+(i%t);\n"
"            b = a+t;\n"
"            if ( ( ( sortList[a] > sortList[b] ) && !dir )\n"
"                 || ( ( sortList[a] < sortList[b] ) && dir ) )\n"
"            {\n"
"               swapF(&sortList[a],&sortList[b]);\n"
"               swapI(&extraList[a],&extraList[b]);\n"
"            }\n"
"         }\n"
"      }\n"
"   }\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Make the final calculation of the spearman coefficient with the given presorted spearman ranking\n"
"// list.\n"
"//\n"
"// @param size Size of the ranking list.\n"
"// @param rankList Presorted spearman ranking list.\n"
"// @return Returns floating point spearman coefficient.\n"
"float calculateSpearman(int size, __global int* rankList)\n"
"{\n"
"   // declare and initialize all variables\n"
"   int i;\n"
"   long tmp;\n"
"   long difference = 0;\n"
"\n"
"   // go through spearman sorted rank list and calculate difference from 1,2,3,... list\n"
"   for (i = 0; i < size ;++i)\n"
"   {\n"
"      tmp = (i+1)-rankList[i];\n"
"      difference += tmp*tmp;\n"
"   }\n"
"\n"
"   // calculate and return spearman coefficient\n"
"   return 1.0-(6.0*(float)difference/((float)size*(((float)size*(float)size)-1.0)));\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Calculate a bulk selection of spearman coefficients with different genes.\n"
"//\n"
"// @param size The size of the expressions/samples per gene.\n"
"// @param workSize The power of 2 work size, MUST be a power of 2.\n"
"// @param targetList Array containing all gene targets to sort.\n"
"// @param expressions Row first 2 dimensional array of all gene expressions.\n"
"// @param workLists Work space to be used for spearman calculations.\n"
"// @param rankLists Work space to be used for spearman calculations.\n"
"// @param resultList Array that will contain all completed spearman coefficients of all gene\n"
"// correlations specified in target list.\n"
"__kernel void calculateSpearmanBlock(int size, int workSize, int minimumSize\n"
"                                     , __global int* targetList, __global float* expressions\n"
"                                     , __global float* workLists, __global int* rankLists\n"
"                                     , __global float* resultList)\n"
"{\n"
"   // initialize all variables and get global id\n"
"   int newSize,pow2Size;\n"
"   int i = get_global_id(0);\n"
"   __global float* listA = &workLists[2*i*workSize];\n"
"   __global float* listB = &workLists[(2*i+1)*workSize];\n"
"   __global int* rankList = &rankLists[i*workSize];\n"
"\n"
"   // fetch gene expressions lists for both genes from target list\n"
"   newSize = fetchLists(targetList[2*i],targetList[2*i+1],size,workSize,listA,listB,rankList\n"
"                        ,expressions);\n"
"\n"
"   // make sure minimum number of related samples is reached\n"
"   if ( newSize >= minimumSize )\n"
"   {\n"
"      // get new power of 2 floor size\n"
"      pow2Size = 2;\n"
"      while ( pow2Size < newSize )\n"
"      {\n"
"         pow2Size *= 2;\n"
"      }\n"
"\n"
"      // execute two bitonic sorts that is beginning of spearman algorithm\n"
"      bitonicSortFF(pow2Size,listA,listB);\n"
"      bitonicSortFI(pow2Size,listB,rankList);\n"
"\n"
"      // calculate spearman coefficient from rearranged rank list and save to result list\n"
"      resultList[i] = calculateSpearman(newSize,rankList);\n"
"   }\n"
"   else\n"
"   {\n"
"      resultList[i] = NAN;\n"
"   }\n"
"}\n"
"";
